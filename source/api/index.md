title: 《程序员的自我休养》笔记
---
《程序员的自我休养》正如周星驰电影中的《演员的自我休养》一样，每个合格的程序员都应该认真的阅读至少二遍。
<!--more-->

## 翻译阶段

### 阶段 1
1) 以实现定义方式，映射源文件（通常是以某种多字节，例如 UTF-8 编码的文本文件）的单独字节为源字符集的字符。特别是以换行字符替换依赖 OS 的行尾指示符。

    __源字符集__ 是包含作为单字节子集的 __基本源字符集__ 的多字节字符集，后者由以下 96 个字符组成：

    a) 5 个空白字符（空格、水平制表、垂直制表、换页、换行）

    b) 10 个数字字符，从 `'0'` 到 `'9'`

    c) 52 个字母，从 `'A'` 到 `'Z'` 以及从 `'a'` 到 `'z'`

    d) 29 个标点字符： `_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " ’`

2) 以对应的单字节表示替换三标符。

### 阶段 2
1) 凡在反斜杠出现于行尾（立即为换行符所后随）时，删除反斜杠和换行符，把二个物理源码行组合成一个逻辑源码行。这是单趟操作：以二个反斜杠结束，后随一个空行的行不会把三行组合为一。

2) 若此步骤后，非空源文件不以换行符结束（无论是原本就无换行，还是以反斜杠结束），则行为未定义。

### 阶段 3
1) 将源文件分解为注释、空白字符（空格、水平制表、换行、垂直制表、换页）序列和下列预处理记号：
    a) 头文件名： <stdio.h> 或 "myfile.h"

    b) 标识符

    c) 预处理数字，包括整数常量和浮点常量，但也包括一些非法记号，例如 1..E+3.foo 或 0JBK

    d) 字符常量与字符串字面量

    e) 运算符与标点，例如 + 、 <<= 、 <% 或 ## 。

    f) 不属于任何其他类别的单独非空白字符

2) 以一个空格字符替换每段注释

3) 保持换行符。是否可将非换行的空白符序列缩减成单个空格字符是实现定义的。

    若已经分析输入为到给定字符为止的预处理记号，则通常将能构成一个预处理记号的最长字符序列处理成下个预处理记号，即这会导致后继分析失败。这常被称为 __最大匹配__ (maximal munch) 。
    ```c
    int foo = 1;
    int bar = 0xE+foo;   // 错误：非法的预处理数字 0xE+foo
    int baz = 0xE + foo; // OK
    
    int quux = bar+++++baz; // 错误： bar++ ++ +baz ，而非 bar++ + ++baz 。
    ```

    __最大匹配__ 规则的单独例外是：

    - 头文件名预处理记号仅在 `#include` 指令中和 `#pragma` 指令中的实现定义位置形成。
    ```c
    #define MACRO_1 1
    #define MACRO_2 2
    #define MACRO_3 3
    #define MACRO_EXPR (MACRO_1 <MACRO_2> MACRO_3) // OK ： <MACRO_2> 不是头文件名
    ```

### 阶段 4
1) 执行预处理器。
2) `#include` 指令所引入的每个文件都经历阶段 1 到 4 ，递归执行。
3) 此阶段结束时，从源码移除所有预处理器指令。

### 阶段 5
1) 将字符常量及字符串字面量中的所有字符及转义序列从源字符集转换成执行字符集（可为如 UTF-8 的多字节字符集，只要来自阶段 1 中所列的基本源字符集的所有 96 个字符拥有单字节表示）。若转义序列所指定的字符不是执行字符集的成员，则结果是实现定义的，但保证不是空（宽）字符。

注意：某些实现中，能以命令行选项控制此阶段所进行的转换： gcc 和 clang 用 `-finput-charset` 指定源字符集的编码，用 `-fexec-charset` 和 `-fwide-exec-charset` 指定无编码前缀的 (C11 起)字符串字面量和字符常量中的执行字符集的编码。

### 阶段 6
连接相邻的字符串字面量。

### 阶段 7
发生编译：按照语法和语义分析记号，并将它们翻译成翻译单元。

### 阶段 8
发生链接：将翻译单元和满足外部引用所需的库组件到汇集成程序映像，它含有在其执行环境（操作系统）中执行所需的信息。


以上过程使用的gcc命令如下：
```bash
gcc -E  #预处理
gcc -S  #编译
gcc -c  #汇编
```

## objdump 使用

```bash
用法：objdump <选项> <文件>
 显示来自目标 <文件> 的信息。
  -h, --[section-]headers 打印section头
  -x, --all-headers 打出所有段信息
  -d, --disassemble 反汇编可执行段
  -s, --full-contents 把所有段的内容以十六进制方式打印出来
```

## readelf 使用
```bash
[zyl@localhost:~]$ readelf --help
用法：readelf <选项> elf-文件
 显示关于 ELF 格式文件内容的信息
 Options are:
  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I
  -h --file-header       Display the ELF file header
  -l --program-headers   Display the program headers
     --segments          An alias for --program-headers
  -S --section-headers   Display the sections' header
     --sections          An alias for --section-headers
```

## 弱符号强符号
1) 强弱符号是针对定义来说的。

2) 编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。

3) 使用 `__attribute__((weak))` 可以指定一个符号为弱符号。

## 弱引用强引用
1) 对外部目标文件中符号的引用在目标文件最终被链接成可执行文件时，它们必须被正确决议。如果没有找到就报链接错误。这种被称为强引用。
2) 与之相对应的还有一种弱引用，在处理弱引用时，如果该符号有定义则链接时决议该符号，如果该符号未定义，则链接时不报错。
3) 使用 `__attribute__((weakref))` 声明一个弱引用。

